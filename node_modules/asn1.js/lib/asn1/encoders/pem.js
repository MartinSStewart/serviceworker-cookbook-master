'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;

function PEMEncoder(entity) {
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data) {

    console.log("PEM");
    console.log(data);
    const buf = this.tree._encodeValue(data).join();
    console.log(buf);
    const p = buf.toString('base64');
    const out = [ '-----BEGIN EC PRIVATE KEY-----' ];
    for (let i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
    out.push('-----END EC PRIVATE KEY-----');
    return out.join('\n');

};

// Tree methods

function DERNode(parent) {
  Node.call(this, parent);
}


DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls);



  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id) {

    id.splice(0, 2, id[0] * 40 + id[1]);

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};


DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {


    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};



// Utility methods

function encodeTag(tag, primitive, cls) {

    const tagByName = ({
        int : 0x02,
        bitstr : 0x03,
        octstr : 0x04,
        objid : 0x06,
        utf8str : 0x0c,
        seq : 0x10
        });

    let res = tagByName[tag];

    if (!primitive)
        res |= 0x20;

    res |= (cls << 6);

    return res;
}


const EncoderBuffer = require('../base/buffer').EncoderBuffer;
const assert = require('minimalistic-assert');

// Supported tags
const tags = [
  'seq', 'objid',
  'int',
  'bitstr',
  'octstr', 'utf8str'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'explicit'
].concat(tags);

// Overrided methods list
const overrided = [
  '_encodeComposite', '_encodeStr', '_encodeObjid',
  '_encodeInt'
];

function Node(parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.obj = false;
  state.use = null;
  state.key = null;
  state.explicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}


const stateProps = [
  'parent', 'children', 'tag', 'args',
  'obj', 'use', 'key', 'explicit'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};


Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  state.explicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};




//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data);
};

Node.prototype._encodeValue = function encode(data, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encodeValue(data);

  let result = null;

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encodeValue(null, data);

      const res = child._encodeValue(data[child._baseState.key], data);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
     if (state.use !== null) {
      result = this._getUse(state.use, parent)._encodeValue(data);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
    const tag = state.tag;
    const cls = 0x0;

    if (tag === null) {
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }


  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 0x2, result);

  return result;
};


Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid')
    return this._encodeObjid(data);
  else if (tag === 'int')
    return this._encodeInt(data, state.args);
  else
    throw new Error('Unsupported tag: ' + tag);
};


inherits(DERNode, Node);