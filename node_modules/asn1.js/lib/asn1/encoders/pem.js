'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;
const EncoderBuffer = require('../base/buffer').EncoderBuffer;
const assert = require('minimalistic-assert');

function PEMEncoder(entity) {
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data) {

    console.log("PEM");
    console.log(data);
    //const buf = this.tree._encodeValue(data).join();
    const buf =
        Buffer.concat(
            [ Buffer.from('30813502810101048120', 'hex')
            , Buffer.from(data.privateKey, 'utf8')
            , Buffer.from('a0810b068108', 'hex')
            , Buffer.from('2a8648ce3d030107', 'hex')
            ]);
    console.log(buf);
    const p = buf.toString('base64');
    const out = [ '-----BEGIN EC PRIVATE KEY-----' ];
    for (let i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
    out.push('-----END EC PRIVATE KEY-----');
    return out.join('\n');

};
//<Buffer 30 81 35 02 81 01 01 04 81 20 f2 4d f6 c0 8c a0 57 bc 57 59 e7 76 cd 9d da 59 33 b6 de 62 6e 0e 7f 5d be 08 76 e5 fd f3 cb 9b a0 81 0b 06 81 08 2a 86 ... 6 more bytes>
//<Buffer 30 81 35 02 81 01 01 04 81 20 f2 4d f6 c0 8c a0 57 bc 57 59 e7 76 cd 9d da 59 33 b6 de 62 6e 0e 7f 5d be 08 76 e5 fd f3 cb 9b a0 81 0b 06 81 08 2a 86 ... 6 more bytes>
//<Buffer 30 81 35 02 81 01 01 04 81 20 f2 4d f6 c0 8c a0 57 bc 57 59 e7 76 cd 9d da 59 33 b6 de 62 6e 0e 7f 5d be 08 76 e5 fd f3 cb 9b a0 81 0b 06 81 08 2a 86 ... 6 more bytes>
//<Buffer 30 81 35 02 81 01 01 04 81 20 a8 38 99 60 b7 b1 94 42 ab bc f5 62 f2 3e e8 19 f5 7a 36 6e 6a 26 b4 cf 21 75 c5 18 d1 2a c9 f6 a0 81 0b 06 81 08 2a 86 ... 6 more bytes>
//<Buffer 30 81 35 02 81 01 01 04 81 20 a8 38 99 60 b7 b1 94 42 ab bc f5 62 f2 3e e8 19 f5 7a 36 6e 6a 26 b4 cf 21 75 c5 18 d1 2a c9 f6 2a 86 48 ce 3d 03 01 07>

// Tree methods

function DERNode(parent) {
  Node.call(this, parent);
}


DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls);

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return new EncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  return new EncoderBuffer(str);

};


// Utility methods

function encodeTag(tag, primitive, cls) {

    const tagByName = ({
        int : 0x02,
        bitstr : 0x03,
        octstr : 0x04,
        objid : 0x06,
        utf8str : 0x0c,
        seq : 0x10
        });

    let res = tagByName[tag];

    if (!primitive)
        res |= 0x20;

    res |= (cls << 6);

    return res;
}




// Supported tags
const tags = [
  'seq', 'objid',
  'int',
  'bitstr',
  'octstr', 'utf8str'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'explicit'
].concat(tags);

// Overrided methods list
const overrided = [
  '_encodeComposite', '_encodeStr', '_encodeObjid'
];

function Node(parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.obj = false;
  state.use = null;
  state.key = null;
  state.explicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}


const stateProps = [
  'parent', 'children', 'tag', 'args',
  'obj', 'use', 'key', 'explicit'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
  }
};


//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};


Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  state.explicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};


Node.prototype._encodeValue = function encode(data, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encodeValue(data);

  let result = null;

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.children) {
    content = state.children.map(function(child) {

      const res = child._encodeValue(data[child._baseState.key], data);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = new EncoderBuffer(content);
  } else {
     if (state.use !== null) {
      result = this._getUse(state.use, parent)._encodeValue(data);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
    const tag = state.tag;

    if (tag === null) {
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, 0x0, content);
    }


  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 0x2, result);

  return result;
};


Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid')
    return new EncoderBuffer(Buffer.from('2a8648ce3d030107', 'hex'));
  else if (tag === 'int')
    return new EncoderBuffer(1);
};


inherits(DERNode, Node);